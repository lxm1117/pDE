/* ================================================================================
----- version 8c ----------------------------------------------------------------------
05Apr10
 Use modified Naf2 to have both Naf and Naf16 with shared properties

----- version 7c ----------------------------------------------------------------------
01Apr10
 Added code to allow spine numbers to be added

----- version 7b ----------------------------------------------------------------------
31Mar10
 Added separate soma parameters
  ifsec "soma" {
    if( vdef( "soma_cm" )) cm	= soma_cm
    if( vdef( "soma_Rm" )) g_pas	= 1/ ( soma_Rm * 1000 )
    if( vdef( "soma_Ra" )) Ra	= soma_Ra
}
----- version 7 ------------------------------------------------------------------------
18Dec08
  Added to do_KDR to be consistent with do_Naf
    ifsec "axon_prox" {	
      if( vdef( "aXp_Gbar_KDR" )) 				gbar_KDR_i1 	= aXp_Gbar_KDR
      ifsec "axon_prox[0]" 	if( vdef( "aXp0_Gbar_KDR" )) 	gbar_KDR_i1 	= aXp0_Gbar_KDR
      ifsec "axon_prox[1]" 	if( vdef( "aXp1_Gbar_KDR" )) 	gbar_KDR_i1 	= aXp1_Gbar_KDR
      ifsec "axon_prox[2]" 	if( vdef( "aXp2_Gbar_KDR" )) 	gbar_KDR_i1 	= aXp2_Gbar_KDR
      ifsec "axon_prox[3]" 	if( vdef( "aXp3_Gbar_KDR" )) 	gbar_KDR_i1 	= aXp3_Gbar_KDR
      ifsec "axon_prox[4]" 	if( vdef( "aXp4_Gbar_KDR" )) 	gbar_KDR_i1 	= aXp4_Gbar_KDR
      ifsec "axon_prox[5]" 	if( vdef( "aXp5_Gbar_KDR" )) 	gbar_KDR_i1 	= aXp5_Gbar_KDR
    }

4Dec08
  Changed   { cvode.active(1) cvode.atol(1.e-4) } to
  { cvode.active(1) cvode.atol(1.e-10) }

3Dec08
  Changed dfc_pG_ddV() and dfc_pG_one_ddV so that plot_ddVs_color will use 
    same color for tgt and sim but thin/thick

  To get ddV from menu right and fix dfc_seg_look_options() for +1500 in 102606b
  changed dfc_i from localobj to objref for pDE_do_fit_case
    so that dfc_i can be referenced in .pDE verbatim code.
  changed dfc_pG_one_ddV adding 
      dfc_i = pDE_fc_list.o( icase )

21Nov08
  Added to control aXp_ densities
    ifsec "axon_prox" {	
      if( vdef( "aXp_Gbar_Naf" )) 				gbar_Naf_i1 	= aXp_Gbar_Naf
      ifsec "axon_prox[0]" 	if( vdef( "aXp0_Gbar_Naf" )) 	gbar_Naf_i1 	= aXp0_Gbar_Naf
      ifsec "axon_prox[1]" 	if( vdef( "aXp1_Gbar_Naf" )) 	gbar_Naf_i1 	= aXp1_Gbar_Naf
      ifsec "axon_prox[2]" 	if( vdef( "aXp2_Gbar_Naf" )) 	gbar_Naf_i1 	= aXp2_Gbar_Naf
      ifsec "axon_prox[3]" 	if( vdef( "aXp3_Gbar_Naf" )) 	gbar_Naf_i1 	= aXp3_Gbar_Naf
      ifsec "axon_prox[4]" 	if( vdef( "aXp4_Gbar_Naf" )) 	gbar_Naf_i1 	= aXp4_Gbar_Naf
      ifsec "axon_prox[5]" 	if( vdef( "aXp5_Gbar_Naf" )) 	gbar_Naf_i1 	= aXp5_Gbar_Naf
    }
  removed line below to avoid conflict with above
    // ifsec "axon" if( vdef("aXp_Gbar_Naf"))			gbar_Naf_i1	= Gbar_Naf + aXp_Gbar_Naf

11Nov08
  Inserted init_last_call() near end of init() as hook to insert changes after set_up and run()
  
  Added obfunc run_plot_all_axon_ddv() 

5nov08
  Added to dfc_run_againL
    rL.o(i).sr.sec cvode.record( &ina( rL.o(i).vr ), eTL.o(i).vec_i, eTL.o(i).vec_t ) // store ina in vec_i
    dropped pDE_init_cell() from dfc_run_again and dfc_run_againL
    Above does not work. Undid changes.
    It's not possible to change anatomy parms if pDE_init_cell() is dropped
    if pDE_init_cell() is kept it is not possible to record &ina; because pDE_init_cell loads a cell anew
      mulfit_cell_init() called by init() adds channels when run() is called.
    catch22!
  Solution 1: insert a function at end of mulfit_cell_init() that does nothing but can be redefined later.

27oct08
  Changed all dfc_eD_options to dfc_seg_look_options

17Oct08
  Added to do_KDR()
   ifsec "soma" 	if(vdef("sO_Gbar_KDR"))			gbar_KDR_i1 	= sO_Gbar_KDR
   ifsec "axon_hill" 	if(vdef("sO_Gbar_KDR"))			gbar_KDR_i1 	= sO_Gbar_KDR

3-Oct08 
  I screwed up with the change I made on 20Sep08 about the BL_avg
  I moved it to after it was used!!!
  Fixed it up today

29Sep08
  I screwed up again with soma_diam_f. I put it in pDE_init_cell 
  but left this line in mulfit_cell_init
     if( vdef( "soma_diam_f")) forsec "soma" diam *= soma_diam_f

27Sep08
  I realized the soma_diam_f can't go in mulfit_cell_init because this get's executed more than once
  It would be OK for a definite value, but not for a factor
  I moved it to pDE_init_cell, right after do_cell()
  if( vdef( "soma_diam_f")) forsec "soma" { diam *= soma_diam_f printf( "soma diam %s %g\n", secname(), diam ) }

25Sep08
  Realized I didn't include the soma_diam_fit code I mentioned 23Sep08
  Let's do it now!

  Added strdef cell_file_name, axon_file_name to pDE_init_cell() so they can set in pDE VERBATIM
        code to default of previous values

23Sep08
  added soma_diam_f fit variable in mulfit_cell_init
     if( vdef( "soma_diam_f")) forsec "soma" diam *= soma_diam_f

20Sep08
  Added message regarding usage of preset BL_avg in dfc_load_traces

19Sep08
  Added dV plot options to dfc_plot_all dfc_pG_one_ddV and dfc_pG_ddV

17Sep08
  changed iss_unstable_penalty from 1e5 to 1e20
  added plot_ddV_all & plot_ddV_color to dfc_plot_all
        dfc_ddVpG, dfc_pG_ddV, dfc_pG_one_ddV
	dfc_seg_look_options()
  removed dfc_seg_look_options() to VERBATIM

11Sep08
  added     printf( "\n\t" ) before system("date) to make printout more legible

10Sep08
  added 
  func round(){ return int( 0.5 + $1 ) }
  and 
  changed dfc_load_dfc_tgt to use round()
  return dfc_tgt.vec_v.mean( round(blmin/dfc_tgt.dt_sample), round(blMax/dfc_tgt.dt_sample)) 
  
  for some reason NEURON would produce different results for what appeared to be identical 
  values of blmin/xxx
  
  added if( dfc_idebug ) printf( "\ndfc_do_cmd: %s\n", so.s2 ) to dfc_do_cmd


12Aug08
Added to do_Naf()
    ifsec "soma" 	if(vdef("sO_Gbar_Naf"))			gbar_Naf_i1 	= sO_Gbar_Naf

Added 	template recSpec
	obfunc dfc_run_againL()
	obfunc dfc_var_runsL()
	obfunc plot_rLL_dt()

08Aug08
Added dfc_run_again, dfc_var_runs and set_sim_stim
Changed execute1 to execute in dfc_do_cmd to reduce printout

04Aug08
Changed set_nseg() so that it will never reduce the number of nsegs in a section
Useful for larger resolution at selected sections

18Jul08
Added 
      if( vdef( "aX_isAp_Gbar_Naf")){  // plus after all other iseg's are set
	// add hotspot to already assigned value
	gbar_Naf_i1 += GaussLike( distance(0.5), aX_isAp_Gbar_Naf, aX_isW_Gbar_Naf, aX_isD_Gbar_Naf )
      }

23Jun08
Added 
    ifsec "axon_iseg[2]" 	if( vdef( "aXi2_Gbar_Naf" )) 	gbar_Naf_i1 	= aXi2_Gbar_Naf
up to aXi9

18Jun08

Added aXp_Gbar_Naf and aXp_Gbar_KDR
Corrected in plot_axon
  in = 19
  if( vdef( "aX_iseg_n" )) in = aX_iseg_n
  for i=0,in-1 pG_sec.append( str.copy().sPrint( "axon_iseg[%d]", i ) )


17Jun08

New axon   do_cell( "n420t-pc2-L10000-ignoreD-newsoma.hoc", "my-ca1-isegs-myelin.hoc" )

----- version 6 ------------------------------------------------------------------------
13Jun08
Added RmCm_spine_gbar variable to select for spines have same gbars of dends when RmCm compensating

12Jun08
switched to Axon ca1b-rot-axon-750-aE-v2.hoc

----- version 5 ------------------------------------------------------------------------
10Jun08
Added aXi01p_Gbar_Naf variable to do_Naf

9Jun08
Added plot_axon to dfc_plot_all()

6Jun08 
changed axon to do_cell( "n420t-pc2-L10000-ignoreD-newsoma.hoc", "ca1b-rot-axon-750-aE.hoc" )
Added is{AWD} for axon_iseg[i] sections
if( vdef( "aX_isA_Gbar_Naf")){  // isA amplitude isW isD
  gbar_Naf_i1 = max( Gbar_Naf, GaussLike( distance(0.5), aX_isA_Gbar_Naf, aX_isW_Gbar_Naf, aX_isD_Gbar_Naf ))
}

----- version 4 ------------------------------------------------------------------------
   Uses cell n420, Verbatim and can simL (run can record from more that one place)
   v2: I reorganized mulfit_cell_init to have a proc for each mechanism (pas+channels)
   Apr08 Jose Ambros-Ingerson
   
   --------------------------------------------------------------------------------
   14May08 
   Changed   { cvode.active(1) cvode.atol(1.e-3) } to   { cvode.active(1) cvode.atol(1.e-4) }
   Changed   do_cell( "n420t-pc2-L10000-ignoreD.hoc", "naceaxon-m-0.hoc" ) to
   do_cell( "n420t-pc2-L10000-ignoreD-newsoma.hoc", "naceaxon-m-0-long.hoc" )

   --------------------------------------------------------------------------------
   9May08
   Changed all do_* to unify notation 

   --------------------------------------------------------------------------------
   6May08 
   changed do_KDR and do_KA to make names consistent and to ignore dslope in axons

   Changed do_cell( "n420t-pc2-F.hoc", "naceaxon-m-0.hoc" )
   to
   do_cell( "n420t-pc2-L10000-ignoreD.hoc", "naceaxon-m-0.hoc" )
   It's the same cell but beter documented
   --------------------------------------------------------------------------------
   1May08 Added
   ifsec "axon" if( vdef( "aX_Gbar_KDR" ))	gbar_KDR_i1 = aX_Gbar_KDR
   and
   ifsec "axon" {
     gbar_KA_i1 = Gbar_KA_soma
     if( vdef( "aX_KAf" )) 	gbar_KA_i1	= Gbar_KA_soma * aX_KAf
   }
   --------------------------------------------------------------------------------
   21Apr08
   Added s particle to Naf channel. sfrac is the fraction of gbar that has s
  
  ================================================================================ */
// Initialize
{ 
  //  load_file( "eTrace-p.hoc", "eTrace_loaded" ) 
  load_file( "eTrace-p.hoc", "eTrace_loaded" ) 
  load_file( "stdrun.hoc" )
  load_file( "eMorph-p.hoc" )
  load_file( "do_log.hoc" )
}
objref RunEnv
{ 
  RunEnv = new str_obj()
  RunEnv.nsystem( "echo $cNeuro", RunEnv.s1 )	// get value of cNeuro environment var into RunEnv.s1
  RunEnv.nsystem( "arch", RunEnv.s2 )		// get arch of machine we're running on on RunEnv.s2
  if( ! strcmp( RunEnv.s2, "ppc" ) ) {		// NMOD_dll filename appropriate to our architecture on RunEnv.s3
    sprint( RunEnv.s3, "%s/lib/nrn/NMOD/ca1n1-mod/powerpc/.libs/libnrnmech.so", RunEnv.s1 )
  } else {
    if( ! strcmp( RunEnv.s2, "i686" ) || ! strcmp( RunEnv.s2, "i386" ) ) {
      sprint( RunEnv.s3, "%s/lib/nrn/NMOD/ca1n1-mod/i686/.libs/libnrnmech.so", RunEnv.s1 )
    } else {
      if( ! strcmp( RunEnv.s2, "x86_64" ) ) {
	sprint( RunEnv.s3, "%s/lib/nrn/NMOD/ca1n1-mod/x86_64/.libs/libnrnmech.so", RunEnv.s1 )
      } else {
        printf( "\n\n\tUnknown architecture >>%s<<\n\n", RunEnv.s2 )
      }
    }
  }
  nrn_load_dll( RunEnv.s3 )
}

//================================================================================
func vdef(){
  if( name_declared( $s1 ) == 5 ) return 1
  return 0
}
//================================================================================
func Boltz(){
  return 1/(1+exp(($1-$2)/$3))
}

func max(){ local i, im
  im = $1
  for i=1, numarg() if( $i>im ) im = $i
  return im
}

func GaussLike(){ // x, A, W, D
  return $2*exp(-($1-$4)^2/$3 )
}

// Perpendicular y distance
func ydistP(){
  return abs( y3d(0)+y3d(n3d()-1) )/2
}

//================================================================================
objref eM
eM = new eMorph()
eM.idebug = 1
dfc_idebug = 0

proc mulfit_cell_init() { 
  soma { distance() }	// set soma(0.5) as reference point
  adj_e_pas = G_e_pas - G_e_pas_slope * tgt_bldiff
  printf( "adj_e_pas %g G_e_pas %g G_e_pas_slope %g tgt_bldiff %g\n", adj_e_pas, G_e_pas, G_e_pas_slope, tgt_bldiff )
  forall {
    do_pas()
    do_Naf2()      // does Naf and Nav16
    do_Naf16()   // Nav 1.6 channels
    do_Nap()
    do_h()
    do_KDR()
    do_KDRa()
    do_KDRb()
    do_KA()
    do_KAa()
  }
  if( vdef( "RmCm_spine_gbar")) execute("eM.RmCm_spine_gbar = RmCm_spine_gbar")  // defaults to 0 in template
  Spnum = 30000
  if( vdef( "Spine_number"))  Spnum = Spine_number
  eM.Spine_Comp_RmCm_f3d( "n420_af3d", Spnum )		// We perform Spine compensation after all else is set.
  eM.idebug = 0						// show debug info only on first run
  set_nseg( lambda_f_d )
}

//--------------------------------------------------------------------------------
proc set_nseg(){ local ns, lfd 
  nseg_tot = 0
  lfd = $1
  soma area( 0.5 )
  forall { 
    if( lfd <= 0 ) ns = 1
    if( lfd >  0 ) ns = int((L/($1 *lambda_f(100))+.9)/2)*2 + 1 
    if( ns > nseg ) nseg = ns
    nseg_tot += nseg
  }
  printf( "lambda-d %g nseg_tot %d\n", lfd, nseg_tot )
}

//--------------------------------------------------------------------------------
proc do_pas(){
  if( !ismembrane("pas") ) insert pas
  e_pas	= adj_e_pas
  g_pas	= 1 / ( G_Rm * 1000 )
  Ra	= G_Ra
  cm	= G_cm
  ifsec "soma" {
    if( vdef( "soma_cm" )) cm	= soma_cm
    if( vdef( "soma_Rm" )) g_pas	= 1/ ( soma_Rm * 1000 )
    if( vdef( "soma_Ra" )) Ra	= soma_Ra
  }
//  ifsec "axon_hill" return	// hillock same as rest of cell
  ifsec "axon" {		// aX_ => generic for all axons but Hillock
    if( vdef( "aX_cm" )) cm	= aX_cm
    if( vdef( "aX_Rm" )) g_pas	= 1/ ( aX_Rm * 1000 )
    if( vdef( "aX_Ra" )) Ra	= aX_Ra
  }
  ifsec "axon_myelin" {		// aXm_ special for myelin can override generic
    if( vdef("aXm_cm"))	cm	= aXm_cm
    if( vdef("aXm_Rm"))	g_pas	= 1/ ( aXm_Rm * 1000 )
    if( vdef("aXm_Ra"))	Ra	= aXm_Ra
  }
  ifsec "axon_node" {		// aXr_ special for nodes of Ranvier can override generic
    if( vdef("aXr_cm"))	cm	= aXr_cm
    if( vdef("aXr_Rm"))	g_pas	= 1/ ( aXr_Rm * 1000 )
    if( vdef("aXr_Ra"))	Ra	= aXr_Ra
  }
}
//--------------------------------------------------------------------------------
proc do_Naf2(){ local i
  if( vdef( "Gbar_Naf" )){
    if( !ismembrane("Naf2_i1")) insert Naf2_i1
    ena = G_ena
    gbar_Naf2_i1 = Gbar_Naf	// default value unless overriden below
    gbar16_Naf2_i1 = 0		// default value unless overriden below
    sfrac_Naf2_i1 = 0		// default is no slow inactivation
    ifsec "dend" {
      if( vdef( "sfrac_y5_Naf" )){
	sfrac_Naf2_i1 = Boltz( ydistP(), sfrac_y5_Naf, sfrac_slp_Naf )
      }
    }
    // aX_  refers to all axon_* but hill and myelin
    // aXh_ refers to hill, aXm_ to myelin, aXi_ to iseg, aXr to Ranvier node

    ifsec "soma" 	if(vdef("sO_Gbar_Naf"))			gbar_Naf2_i1 	= sO_Gbar_Naf
    ifsec "axon_hill" 	if(vdef("sO_Gbar_Naf"))			gbar_Naf2_i1 	= sO_Gbar_Naf

    ifsec "axon_hill" 	if(vdef("aXh_Gbar_Naf"))		gbar_Naf2_i1 	= aXh_Gbar_Naf
    ifsec "axon_myelin" if(vdef("aXm_Gbar_Naf"))		gbar_Naf2_i1 	= aXm_Gbar_Naf
    if( issection("axon_myelin.*") || issection("axon_hill.*" ) ) return

    ifsec "axon" if( vdef("aX_Gbar_Naf"))			gbar_Naf2_i1	= aX_Gbar_Naf
    // ifsec "axon" if( vdef("aXp_Gbar_Naf"))			gbar_Naf2_i1	= Gbar_Naf + aXp_Gbar_Naf
    ifsec "axon_iseg" {	
      if( vdef( "aX_isA_Gbar_Naf")){  // isA amplitude isW isD
	// max between already assigned value and hotspot
	gbar_Naf2_i1 = max( gbar_Naf2_i1, GaussLike( distance(0.5), aX_isA_Gbar_Naf, aX_isW_Gbar_Naf, aX_isD_Gbar_Naf ))
      }
      if( vdef( "aX_ispA_Gbar_Naf")){  // isA amplitude isW isD
	// add hotspot to already assigned value
	gbar_Naf2_i1 += GaussLike( distance(0.5), aX_ispA_Gbar_Naf, aX_isW_Gbar_Naf, aX_isD_Gbar_Naf )
      }
      if( vdef( "aXi_Gbar_Naf" )) 				gbar_Naf2_i1 	= aXi_Gbar_Naf
      ifsec "axon_iseg[0]" 	if( vdef( "aXi0_Gbar_Naf" )) 	gbar_Naf2_i1 	= aXi0_Gbar_Naf
      ifsec "axon_iseg[1]" 	if( vdef( "aXi1_Gbar_Naf" )) 	gbar_Naf2_i1 	= aXi1_Gbar_Naf
      ifsec "axon_iseg[2]" 	if( vdef( "aXi2_Gbar_Naf" )) 	gbar_Naf2_i1 	= aXi2_Gbar_Naf
      ifsec "axon_iseg[3]" 	if( vdef( "aXi3_Gbar_Naf" )) 	gbar_Naf2_i1 	= aXi3_Gbar_Naf
      ifsec "axon_iseg[4]" 	if( vdef( "aXi4_Gbar_Naf" )) 	gbar_Naf2_i1 	= aXi4_Gbar_Naf
      ifsec "axon_iseg[5]" 	if( vdef( "aXi5_Gbar_Naf" )) 	gbar_Naf2_i1 	= aXi5_Gbar_Naf
      ifsec "axon_iseg[6]" 	if( vdef( "aXi6_Gbar_Naf" )) 	gbar_Naf2_i1 	= aXi6_Gbar_Naf
      ifsec "axon_iseg[7]" 	if( vdef( "aXi7_Gbar_Naf" )) 	gbar_Naf2_i1 	= aXi7_Gbar_Naf
      ifsec "axon_iseg[8]" 	if( vdef( "aXi8_Gbar_Naf" )) 	gbar_Naf2_i1 	= aXi8_Gbar_Naf
      ifsec "axon_iseg[9]" 	if( vdef( "aXi9_Gbar_Naf" )) 	gbar_Naf2_i1 	= aXi9_Gbar_Naf
      if( vdef( "aXi01p_Gbar_Naf" )) {
	ifsec "axon_iseg[0]" 					gbar_Naf2_i1 	= Gbar_Naf + aXi01p_Gbar_Naf
	ifsec "axon_iseg[1]" 					gbar_Naf2_i1 	= Gbar_Naf + aXi01p_Gbar_Naf
      }
      if( vdef( "aX_isAp_Gbar_Naf")){  // plus after all other iseg's are set
	// add hotspot to already assigned value
	gbar_Naf2_i1 += GaussLike( distance(0.5), aX_isAp_Gbar_Naf, aX_isW_Gbar_Naf, aX_isD_Gbar_Naf )
      }
    }
    ifsec "axon_prox" {	
      if( vdef( "aXp_Gbar_Naf" )) 				gbar_Naf2_i1 	= aXp_Gbar_Naf
      ifsec "axon_prox[0]" 	if( vdef( "aXp0_Gbar_Naf" )) 	gbar_Naf2_i1 	= aXp0_Gbar_Naf
      ifsec "axon_prox[1]" 	if( vdef( "aXp1_Gbar_Naf" )) 	gbar_Naf2_i1 	= aXp1_Gbar_Naf
      ifsec "axon_prox[2]" 	if( vdef( "aXp2_Gbar_Naf" )) 	gbar_Naf2_i1 	= aXp2_Gbar_Naf
      ifsec "axon_prox[3]" 	if( vdef( "aXp3_Gbar_Naf" )) 	gbar_Naf2_i1 	= aXp3_Gbar_Naf
      ifsec "axon_prox[4]" 	if( vdef( "aXp4_Gbar_Naf" )) 	gbar_Naf2_i1 	= aXp4_Gbar_Naf
      ifsec "axon_prox[5]" 	if( vdef( "aXp5_Gbar_Naf" )) 	gbar_Naf2_i1 	= aXp5_Gbar_Naf
    }
    ifsec "axon_node"       	if( vdef( "aXr_Gbar_Naf" )) 	gbar_Naf2_i1 	= aXr_Gbar_Naf
    ifsec "axon_node"       	if( vdef( "aXrp_Gbar_Naf" )) 	gbar_Naf2_i1 	= Gbar_Naf + aXrp_Gbar_Naf
    ifsec "axon_node"       	if( vdef( "aXrpp_Gbar_Naf" )) 	gbar_Naf2_i1 	= aX_Gbar_Naf + aXrpp_Gbar_Naf
  }
}

//end or normal Naf.  Start of Naf16

proc do_Naf16(){ local i
//    ifsec "soma" return
//    ifsec "dend" return
    ifsec "spine" return
   
    if( vdef( "Gbar_Naf16")) gbar16_Naf2_i1 = Gbar_Naf16  //default value unless overridden below
 
    ifsec "soma"   if(vdef("sO_Gbar_Naf16"))               gbar16_Naf2_i1   = sO_Gbar_Naf16
    ifsec "axon_hill"   if(vdef("sO_Gbar_Naf16"))               gbar16_Naf2_i1   = sO_Gbar_Naf16

    ifsec "axon_hill"   if(vdef("aXh_Gbar_Naf16"))              gbar16_Naf2_i1   = aXh_Gbar_Naf16
    ifsec "axon_myelin" if(vdef("aXm_Gbar_Naf16"))              gbar16_Naf2_i1   = aXm_Gbar_Naf16
    if( issection("axon_myelin.*") || issection("axon_hill.*" ) ) return

    ifsec "axon" if( vdef("aX_Gbar_Naf16"))                     gbar16_Naf2_i1   = aX_Gbar_Naf16
    // ifsec "axon" if( vdef("aXp_Gbar_Naf16"))                 gbar16_Naf2_i1   = Gbar_Naf + aXp_Gbar_Naf16
    ifsec "axon_iseg" {	
      if( vdef( "aX_isA_Gbar_Naf16")){  // isA amplitude isW isD
	// max between already assigned value and hotspot
	gbar16_Naf2_i1 = max( gbar16_Naf2_i1, GaussLike( distance(0.5), aX_isA_Gbar_Naf16, aX_isW_Gbar_Naf16, aX_isD_Gbar_Naf16 ))
      }
      if( vdef( "aX_ispA_Gbar_Naf16")){  // isA amplitude isW isD
	// add hotspot to already assigned value
	gbar16_Naf2_i1 += GaussLike( distance(0.5), aX_ispA_Gbar_Naf16, aX_isW_Gbar_Naf16, aX_isD_Gbar_Naf16 )
      }
      if( vdef( "aXi_Gbar_Naf16" )) 				gbar16_Naf2_i1 	= aXi_Gbar_Naf16
      ifsec "axon_iseg[0]" 	if( vdef( "aXi0_Gbar_Naf16" )) 	gbar16_Naf2_i1 	= aXi0_Gbar_Naf16
      ifsec "axon_iseg[1]" 	if( vdef( "aXi1_Gbar_Naf16" )) 	gbar16_Naf2_i1 	= aXi1_Gbar_Naf16
      ifsec "axon_iseg[2]" 	if( vdef( "aXi2_Gbar_Naf16" )) 	gbar16_Naf2_i1 	= aXi2_Gbar_Naf16
      ifsec "axon_iseg[3]" 	if( vdef( "aXi3_Gbar_Naf16" )) 	gbar16_Naf2_i1 	= aXi3_Gbar_Naf16
      ifsec "axon_iseg[4]" 	if( vdef( "aXi4_Gbar_Naf16" )) 	gbar16_Naf2_i1 	= aXi4_Gbar_Naf16
      ifsec "axon_iseg[5]" 	if( vdef( "aXi5_Gbar_Naf16" )) 	gbar16_Naf2_i1 	= aXi5_Gbar_Naf16
      ifsec "axon_iseg[6]" 	if( vdef( "aXi6_Gbar_Naf16" )) 	gbar16_Naf2_i1 	= aXi6_Gbar_Naf16
      ifsec "axon_iseg[7]" 	if( vdef( "aXi7_Gbar_Naf16" )) 	gbar16_Naf2_i1 	= aXi7_Gbar_Naf16
      ifsec "axon_iseg[8]" 	if( vdef( "aXi8_Gbar_Naf16" )) 	gbar16_Naf2_i1 	= aXi8_Gbar_Naf16
      ifsec "axon_iseg[9]" 	if( vdef( "aXi9_Gbar_Naf16" )) 	gbar16_Naf2_i1 	= aXi9_Gbar_Naf16
      if( vdef( "aXi01p_Gbar_Naf16" )) {
	ifsec "axon_iseg[0]" 					gbar16_Naf2_i1 	= Gbar_Naf + aXi01p_Gbar_Naf16
	ifsec "axon_iseg[1]" 					gbar16_Naf2_i1 	= Gbar_Naf + aXi01p_Gbar_Naf16
      }
      if( vdef( "aX_isAp_Gbar_Naf16")){  // plus after all other iseg's are set
	// add hotspot to already assigned value
	gbar16_Naf2_i1 += GaussLike( distance(0.5), aX_isAp_Gbar_Naf16, aX_isW_Gbar_Naf16, aX_isD_Gbar_Naf16 )
      }
    }
    ifsec "axon_prox" {	
      if( vdef( "aXp_Gbar_Naf16" )) 				gbar16_Naf2_i1 	= aXp_Gbar_Naf16
      ifsec "axon_prox[0]" 	if( vdef( "aXp0_Gbar_Naf16" )) 	gbar16_Naf2_i1 	= aXp0_Gbar_Naf16
      ifsec "axon_prox[1]" 	if( vdef( "aXp1_Gbar_Naf16" )) 	gbar16_Naf2_i1 	= aXp1_Gbar_Naf16
      ifsec "axon_prox[2]" 	if( vdef( "aXp2_Gbar_Naf16" )) 	gbar16_Naf2_i1 	= aXp2_Gbar_Naf16
      ifsec "axon_prox[3]" 	if( vdef( "aXp3_Gbar_Naf16" )) 	gbar16_Naf2_i1 	= aXp3_Gbar_Naf16
      ifsec "axon_prox[4]" 	if( vdef( "aXp4_Gbar_Naf16" )) 	gbar16_Naf2_i1 	= aXp4_Gbar_Naf16
      ifsec "axon_prox[5]" 	if( vdef( "aXp5_Gbar_Naf16" )) 	gbar16_Naf2_i1 	= aXp5_Gbar_Naf16
    }
    ifsec "axon_node"       	if( vdef( "aXr_Gbar_Naf16" )) 	gbar16_Naf2_i1 	= aXr_Gbar_Naf16
    ifsec "axon_node"       	if( vdef( "aXrp_Gbar_Naf16" )) 	gbar16_Naf2_i1 	= Gbar_Naf + aXrp_Gbar_Naf16
    ifsec "axon_node"       	if( vdef( "aXrpp_Gbar_Naf16" ))	gbar16_Naf2_i1 	= aX_Gbar_Naf16 + aXrpp_Gbar_Naf16
}
//--------------------------------------------------------------------------------
proc do_Nap(){
  if( vdef( "Gbar_Nap" )){
    if( !ismembrane("Nap_i0") ) insert Nap_i0
    ena = G_ena
    gbar_Nap_i0 = Gbar_Nap

    ifsec "axon_hill" 	if(vdef("aXh_Gbar_Nap"))		gbar_Nap_i1 	= aXh_Gbar_Nap
    ifsec "axon_myelin" if(vdef("aXm_Gbar_Nap"))		gbar_Nap_i1 	= aXm_Gbar_Nap
    if( issection("axon_myelin.*") || issection("axon_hill.*" ) ) return

    ifsec "axon" if( vdef("aX_Gbar_Nap"))			gbar_Nap_i1	= aX_Gbar_Nap
    ifsec "axon_iseg" {	
      if( vdef( "aXi_Gbar_Nap" )) 				gbar_Nap_i1 	= aXi_Gbar_Nap
      ifsec "axon_iseg[0]" 	if( vdef( "aXi0_Gbar_Nap" )) 	gbar_Nap_i1 	= aXi0_Gbar_Nap
      ifsec "axon_iseg[1]" 	if( vdef( "aXi1_Gbar_Nap" )) 	gbar_Nap_i1 	= aXi1_Gbar_Nap
    }
    ifsec "axon_node"       	if( vdef( "aXr_Gbar_Nap" )) 	gbar_Nap_i1 	= aXr_Gbar_Nap
    ifsec "axon_myelin"       	if( vdef( "aXm_Gbar_Nap" )) 	gbar_Nap_i1 	= aXm_Gbar_Nap
  }
}
//--------------------------------------------------------------------------------
proc do_KDR(){ local i
  if( vdef( "Gbar_KDR" )){
    if( !ismembrane("KDR_i1") ) insert KDR_i1
    ek = G_ek
    gbar_KDR_i1 = Gbar_KDR
    if(vdef("Gbar_KDR_dslope") && !issection("axon.*")) 	gbar_KDR_i1 = Gbar_KDR *(1+Gbar_KDR_dslope*ydistP())

    ifsec "soma" 	if(vdef("sO_Gbar_KDR"))			gbar_KDR_i1 	= sO_Gbar_KDR
    ifsec "axon_hill" 	if(vdef("sO_Gbar_KDR"))			gbar_KDR_i1 	= sO_Gbar_KDR

    ifsec "axon_hill" 	if(vdef("aXh_Gbar_KDR"))		gbar_KDR_i1 	= aXh_Gbar_KDR
    ifsec "axon_myelin" if(vdef("aXm_Gbar_KDR"))		gbar_KDR_i1 	= aXm_Gbar_KDR
    if( issection("axon_myelin.*") || issection("axon_hill.*" ) ) return

    ifsec "axon" if( vdef("aX_Gbar_KDR"))			gbar_KDR_i1	= aX_Gbar_KDR
    ifsec "axon_iseg" {	
      if( vdef( "aXi_Gbar_KDR" )) 				gbar_KDR_i1 	= aXi_Gbar_KDR
      ifsec "axon_iseg[0]" 	if( vdef( "aXi0_Gbar_KDR" )) 	gbar_KDR_i1 	= aXi0_Gbar_KDR
      ifsec "axon_iseg[1]" 	if( vdef( "aXi1_Gbar_KDR" )) 	gbar_KDR_i1 	= aXi1_Gbar_KDR
    }
    ifsec "axon_prox" {	
      if( vdef( "aXp_Gbar_KDR" )) 				gbar_KDR_i1 	= aXp_Gbar_KDR
      ifsec "axon_prox[0]" 	if( vdef( "aXp0_Gbar_KDR" )) 	gbar_KDR_i1 	= aXp0_Gbar_KDR
      ifsec "axon_prox[1]" 	if( vdef( "aXp1_Gbar_KDR" )) 	gbar_KDR_i1 	= aXp1_Gbar_KDR
      ifsec "axon_prox[2]" 	if( vdef( "aXp2_Gbar_KDR" )) 	gbar_KDR_i1 	= aXp2_Gbar_KDR
      ifsec "axon_prox[3]" 	if( vdef( "aXp3_Gbar_KDR" )) 	gbar_KDR_i1 	= aXp3_Gbar_KDR
      ifsec "axon_prox[4]" 	if( vdef( "aXp4_Gbar_KDR" )) 	gbar_KDR_i1 	= aXp4_Gbar_KDR
      ifsec "axon_prox[5]" 	if( vdef( "aXp5_Gbar_KDR" )) 	gbar_KDR_i1 	= aXp5_Gbar_KDR
    }
    ifsec "axon_node"       	if( vdef( "aXr_Gbar_KDR" )) 	gbar_KDR_i1 	= aXr_Gbar_KDR
    ifsec "axon_myelin"       	if( vdef( "aXm_Gbar_KDR" )) 	gbar_KDR_i1 	= aXm_Gbar_KDR
  }
}
//--------------------------------------------------------------------------------
proc do_KDRa(){ 
  if( vdef( "Gbar_KDRa" )){
    if( !ismembrane("KDRa_i1") ) insert KDRa_i1
    ek = G_ek
    gbar_KDRa_i1 = Gbar_KDRa

    ifsec "axon_hill" 	if(vdef("aXh_Gbar_KDRa"))		gbar_KDRa_i1 	= aXh_Gbar_KDRa
    ifsec "axon_myelin" if(vdef("aXm_Gbar_KDRa"))		gbar_KDRa_i1 	= aXm_Gbar_KDRa
    if( issection("axon_myelin.*") || issection("axon_hill.*" ) ) return

    ifsec "axon" if( vdef("aX_Gbar_KDRa"))			gbar_KDRa_i1	= aX_Gbar_KDRa
    ifsec "axon_iseg" {	
      if( vdef( "aXi_Gbar_KDRa" )) 				gbar_KDRa_i1 	= aXi_Gbar_KDRa
      ifsec "axon_iseg[0]" 	if( vdef( "aXi0_Gbar_KDRa" )) 	gbar_KDRa_i1 	= aXi0_Gbar_KDRa
      ifsec "axon_iseg[1]" 	if( vdef( "aXi1_Gbar_KDRa" )) 	gbar_KDRa_i1 	= aXi1_Gbar_KDRa
    }
    ifsec "axon_node"       	if( vdef( "aXr_Gbar_KDRa" )) 	gbar_KDRa_i1 	= aXr_Gbar_KDRa
    ifsec "axon_myelin"       	if( vdef( "aXm_Gbar_KDRa" )) 	gbar_KDRa_i1 	= aXm_Gbar_KDRa
  }
}
//--------------------------------------------------------------------------------
proc do_KDRb(){ 
  if( vdef( "Gbar_KDRb" )){
    if( !ismembrane("KDRb_i1") ) insert KDRb_i1
    ek = G_ek
    gbar_KDRb_i1 = Gbar_KDRb

    ifsec "axon_hill" 	if(vdef("aXh_Gbar_KDRb"))		gbar_KDRb_i1 	= aXh_Gbar_KDRb
    ifsec "axon_myelin" if(vdef("aXm_Gbar_KDRb"))		gbar_KDRb_i1 	= aXm_Gbar_KDRb
    if( issection("axon_myelin.*") || issection("axon_hill.*" ) ) return

    ifsec "axon" if( vdef("aX_Gbar_KDRb"))			gbar_KDRb_i1	= aX_Gbar_KDRb
    ifsec "axon_iseg" {	
      if( vdef( "aXi_Gbar_KDRb" )) 				gbar_KDRb_i1 	= aXi_Gbar_KDRb
      ifsec "axon_iseg[0]" 	if( vdef( "aXi0_Gbar_KDRb" )) 	gbar_KDRb_i1 	= aXi0_Gbar_KDRb
      ifsec "axon_iseg[1]" 	if( vdef( "aXi1_Gbar_KDRb" )) 	gbar_KDRb_i1 	= aXi1_Gbar_KDRb
    }
    ifsec "axon_node"       	if( vdef( "aXr_Gbar_KDRb" )) 	gbar_KDRb_i1 	= aXr_Gbar_KDRb
    ifsec "axon_myelin"       	if( vdef( "aXm_Gbar_KDRb" )) 	gbar_KDRb_i1 	= aXm_Gbar_KDRb
  }
}
//--------------------------------------------------------------------------------
proc do_KA(){ local i
  if( vdef( "Gbar_KA" )){
    if( !ismembrane("KA_i1") ) insert KA_i1
    ek = G_ek
    gbar_KA_i1 = Gbar_KA
    if(vdef("Gbar_KA_dslope") && !issection("axon.*")) 		gbar_KA_i1 = Gbar_KA *(1+Gbar_KA_dslope*ydistP() )

    ifsec "axon_hill" 	if(vdef("aXh_Gbar_KA"))			gbar_KA_i1 	= aXh_Gbar_KA
    ifsec "axon_myelin" if(vdef("aXm_Gbar_KA"))			gbar_KA_i1 	= aXm_Gbar_KA
    if( issection("axon_myelin.*") || issection("axon_hill.*" ) ) return

    ifsec "axon" if( vdef("aX_Gbar_KA"))			gbar_KA_i1	= aX_Gbar_KA
    ifsec "axon_iseg" {	
      if( vdef( "aXi_Gbar_KA" )) 				gbar_KA_i1 	= aXi_Gbar_KA
      ifsec "axon_iseg[0]" 	if( vdef( "aXi0_Gbar_KA" )) 	gbar_KA_i1 	= aXi0_Gbar_KA
      ifsec "axon_iseg[1]" 	if( vdef( "aXi1_Gbar_KA" )) 	gbar_KA_i1 	= aXi1_Gbar_KA
    }
    ifsec "axon_node"       	if( vdef( "aXr_Gbar_KA" )) 	gbar_KA_i1 	= aXr_Gbar_KA
    ifsec "axon_myelin"       	if( vdef( "aXm_Gbar_KA" )) 	gbar_KA_i1 	= aXm_Gbar_KA
  }
}
//--------------------------------------------------------------------------------
proc do_KAa(){ local i
  if( vdef( "Gbar_KAa" )){
    if( !ismembrane("KAa_i1") ) insert KAa_i1
    ek = G_ek
    gbar_KAa_i1 = Gbar_KAa
    if(vdef("Gbar_KAa_dslope") && !issection("axon.*")) 	gbar_KAa_i1 = Gbar_KAa *(1+Gbar_KAa_dslope*ydistP() )

    ifsec "axon_hill" 	if(vdef("aXh_Gbar_KAa"))		gbar_KAa_i1 	= aXh_Gbar_KAa
    ifsec "axon_myelin" if(vdef("aXm_Gbar_KAa"))		gbar_KAa_i1 	= aXm_Gbar_KAa
    if( issection("axon_myelin.*") || issection("axon_hill.*" ) ) return

    ifsec "axon" if( vdef("aX_Gbar_KAa"))			gbar_KAa_i1	= aX_Gbar_KAa
    ifsec "axon_iseg" {	
      if( vdef( "aXi_Gbar_KAa" )) 				gbar_KAa_i1 	= aXi_Gbar_KAa
      ifsec "axon_iseg[0]" 	if( vdef( "aXi0_Gbar_KAa" )) 	gbar_KAa_i1 	= aXi0_Gbar_KAa
      ifsec "axon_iseg[1]" 	if( vdef( "aXi1_Gbar_KAa" )) 	gbar_KAa_i1 	= aXi1_Gbar_KAa
    }
    ifsec "axon_node"       	if( vdef( "aXr_Gbar_KAa" )) 	gbar_KAa_i1 	= aXr_Gbar_KAa
    ifsec "axon_myelin"       	if( vdef( "aXm_Gbar_KAa" )) 	gbar_KAa_i1 	= aXm_Gbar_KAa
  }
}
//--------------------------------------------------------------------------------
proc do_h(){ local i
  if( vdef( "Gbar_h" )){
    if( !ismembrane("h_i0") ) insert h_i0
    eh_i0 = G_eh
    gbar_h_i0 = Gbar_h
    if(vdef("Gbar_h_dslope") && !issection(".*axon.*")) 	gbar_h_i0 = Gbar_h *(1+Gbar_h_dslope*ydistP() )

    ifsec "axon_hill" 	if(vdef("aXh_Gbar_h"))			gbar_h_i0 	= aXh_Gbar_h
    ifsec "axon_myelin" if(vdef("aXm_Gbar_h"))			gbar_h_i0 	= aXm_Gbar_h
    if( issection("axon_myelin.*") || issection("axon_hill.*" ) ) return

    ifsec "axon" if( vdef("aX_Gbar_h"))				gbar_h_i0	= aX_Gbar_h
    ifsec "axon_iseg" {	
      if( vdef( "aXi_Gbar_h" )) 				gbar_h_i0 	= aXi_Gbar_h
      ifsec "axon_iseg[0]" 	if( vdef( "aXi0_Gbar_h" )) 	gbar_h_i0 	= aXi0_Gbar_h
      ifsec "axon_iseg[1]" 	if( vdef( "aXi0_Gbar_h" )) 	gbar_h_i0 	= aXi1_Gbar_h
    }
    ifsec "axon_prox"       	if( vdef( "aXp_Gbar_h" )) 	gbar_h_i0 	= aXp_Gbar_h
    ifsec "axon_node"       	if( vdef( "aXr_Gbar_h" )) 	gbar_h_i0 	= aXr_Gbar_h
    ifsec "axon_myelin"       	if( vdef( "aXm_Gbar_h" )) 	gbar_h_i0 	= aXm_Gbar_h
  }
}

//----------------------------------------------------------------------
objref iss
init_first = 1
iss_unstable = 0 	// set 0 to find out; once set avoid running again
proc init() {   local v0, v1 
  if( init_first ){
    init_first = 0
    // calculate G_e_pas_slope to adjust e_pas for each trace's baseline
    G_e_pas_slope = 0
    G_e_pas += 1
    mulfit_cell_init()
    iss.init_steady_state	// init_steady_state()
    if( check_iss_unstable()) return
    v1 = v
    G_e_pas -= 1
    mulfit_cell_init()
    iss.init_steady_state	// init_steady_state()
    if( check_iss_unstable()) return
    v0 = v
    G_e_pas_slope = 1/(v1-v0)
    printf( "init: G_e_pas_slope %g\n", G_e_pas_slope )
    
  }
  mulfit_cell_init()
  init_last_call()	// hook to insert changes just before run() call
  iss.init_steady_state() // init_steady_state()
  if( check_iss_unstable()) return
}

// Hook to insert changes just before run() call (can be redefined later)
proc init_last_call(){
}

//----------------------------------------------------------------------
func check_iss_unstable(){
  if( iss.dV > iss_unstable_th ){
    iss_unstable = 1
    printf( ">>>init: UNSTABLE Steady State iss.dV=%g iss_unstable_th=%g; setting tstop=20<<<\n", \
    iss.dV, iss_unstable_th )
    tstop = 20
    return 1
  }
  return 0
}

//----------------------------------------------------------------------
objref stim
proc do_cell(){
  
  forall delete_section()
  load_file( 1, $s1 )	// load cell
  if( numarg()>1 ) load_file( 1, $s2 )	// load axon
  soma {
    stim	= new IClamp(0.5)
    stim.del 	= 20
    stim.dur 	= 80
    stim.amp 	= 0.8
  }
}

//================================================================================
// pDE interface related code

begintemplate pDE_fit_case
  strdef id, Mtemplate, Mfunc, scaleF, hoc_var, hoc_before, hoc_after, tgt_file, tgt_before, tgt_after
  public id, Mtemplate, Mfunc, scaleF, hoc_var, hoc_before, hoc_after, tgt_file, tgt_before, tgt_after
  public scaleF, tgt_bldiff
  proc init(){
    id		= $s1
    Mtemplate 	= $s2
    Mfunc	= $s3
    scaleF	= $s4
    hoc_var	= $s5
    hoc_before	= $s6
    hoc_after	= $s7
    tgt_file	= $s8
    tgt_before  = $s9
    tgt_after  	= $s10
    
    tgt_bldiff	= 0	// baseline differential from avg of tgt set
  }
endtemplate pDE_fit_case

proc dfc_do_cmd(){ localobj so, sf
  sf = new StringFunctions()
  so = new str_obj()
  sprint( so.s1, "%s;", $s1 )
  while( strcmp( so.s1, "")){
    sf.head( so.s1, ";", so.s2  )
    if( strcmp( so.s2, "" )) {
      if( dfc_idebug ) printf( "\ndfc_do_cmd: %s\n", so.s2 )
      if( numarg() == 1 ) execute( so.s2 )
      if( numarg() == 2 ) execute( so.s2, $o2 )
      if( numarg() == 3 ) $o3.append( new str_obj( so.s2 ))
    }
    sf.tail( so.s1, ";", so.s1  )
  }
}

//----------------------------------------------------------------------------------------------------
objref pDE_fc_list
objref dfc_tgt, dfc_tgtL
{ blmin=1 blMax=19 } // baseline limits (ms)

func dfc_load_dfc_tgt(){ local i localobj fc_i, sf, str, pDE_fc_i
  pDE_fc_i=$o1
  sf=new StringFunctions() str=new str_obj()
  dfc_tgt = new eTrace()
  dfc_tgt.idebug = dfc_idebug
  dfc_do_cmd( pDE_fc_i.tgt_before )
  if( sf.head( pDE_fc_i.tgt_file, ".txt$", str.s1 ) >= 0 ) dfc_tgt.load_file_home( pDE_fc_i.tgt_file )
  if( sf.head( pDE_fc_i.tgt_file, ".htf$", str.s1 ) >= 0 ) dfc_tgt.load_htf_1p0c( pDE_fc_i.tgt_file, "HOME" )
  dfc_do_cmd( pDE_fc_i.tgt_after )
  return dfc_tgt.vec_v.mean( round(blmin/dfc_tgt.dt_sample), round(blMax/dfc_tgt.dt_sample)) // return mean from blmin to blMax
}

func round(){ return int( 0.5 + $1 ) }

proc dfc_load_traces(){ local i, j, tmp, bl_avg, bl_i localobj pDE_fc_i, blV
  dfc_tgtL = new List()
  blV = new Vector()
  bl_avg = 0
  for i=0, pDE_fc_list.count-1 { 
    bl_i = dfc_load_dfc_tgt( pDE_fc_list.o(i) )
    dfc_tgtL.append( dfc_tgt )
    blV.append( bl_i )
    bl_avg += (bl_i - bl_avg)/(i+1)			// clever way to compute running avg
  }
  printf( "dfc_load_traces: found bl_avg %g.\n", bl_avg )
  if( vdef( "BL_avg" )) {
    printf( "dfc_load_traces: Using preset BL_avg %g\n", BL_avg )
    bl_avg = BL_avg          // Use BL_avg if defined in pDE script
  }
  for i=0, pDE_fc_list.count-1 {
    pDE_fc_list.o(i).tgt_bldiff = bl_avg - blV.x[i]
    printf( "dfc_load_traces i %d bli %g bl_avg %g tgt_bldiff %g\n", i, blV.x[i], bl_avg, pDE_fc_list.o(i).tgt_bldiff )
  }
}

//----------------------------------------------------------------------------------------------------
strdef cell_file_name, axon_file_name	// so they can be defined in pDE VERBATIM
proc pDE_init_cell(){
  // Not needed here. Out so that dfc_run_agai works  pDE_asg()	// so that do_cell can use name_declared() calls
  //  do_cell( "n420t-pc2-L10000-ignoreD-newsoma.hoc", "naceaxon-m-0-long.hoc" )
  //  do_cell( "n420t-pc2-L10000-ignoreD-newsoma.hoc", "Meeks-axon-0.hoc" )
  //  do_cell( "n420t-pc2-L10000-ignoreD-newsoma.hoc", "ca1b-rot-axon-750-aE-v2.hoc" )
  //  do_cell( "n420t-pc2-L10000-ignoreD-newsoma.hoc", "my-ca1-isegs-myelin.hoc" )
  //  do_cell( "n420t-pc2-L10000-DL.hoc", "my-ca1-isegs-myelin.hoc" ) 
  if( strcmp(cell_file_name,"")==0 ) cell_file_name = "n420t-pc2-L10000-DL.hoc"
  if( strcmp(axon_file_name,"")==0 ) axon_file_name = "my-ca1-isegs-myelin-v2.hoc"
  do_cell( cell_file_name, axon_file_name ) 
  if( vdef( "soma_diam_f")) forsec "soma" { diam *= soma_diam_f printf( "soma diam %s %g\n", secname(), diam ) }
  
  { cvode.active(1) cvode.atol(1.e-10) }

  iss = new initss( cvode, -80 )		// iss_v_init = -80
  iss.idebug = 0.5
  iss_unstable_th = 0.1
  iss_unstable_penalty = 1e20

  execute( "access soma" )			// avoid sintax error if soma is not created at compile time
}

//----------------------------------------------------------------------------------------------------
obfunc set_sim_stim(){ local i localobj eT, sT
  { eT = $o1 sT=$o2 }
  { eT.stim_amp=sT.amp eT.stim_del=sT.del eT.stim_dur=sT.dur }
  return eT
}

//----------------------------------------------------------------------------------------------------
objref dfc_i, dfc_tgt_i, dfc_sim, dfc_sim_rec, dfc_simL, dfc_eD
objref dfc_recL, dfc_simL_i, dfc_sim_recL

dfc_first = 1
func pDE_do_fit_case(){ local i, icase, irec localobj str, sL
  icase = $1
  if( dfc_first ) {
    dfc_first = 0
    dfc_simL = new List()
    pDE_asg()                   // so that init_cell and load_traces can use vdef() calls
    dfc_load_traces()
    pDE_init_cell()
  }
  dfc_i = pDE_fc_list.o( icase )
  dfc_tgt_i = dfc_tgtL.o( icase )
  
  str = new str_obj() 
  execute( str.sPrint( "dfc_eD = new %s()", dfc_i.Mtemplate ).s1 )
  dfc_eD.idebug = dfc_idebug
  tstop = dfc_tgt_i.vec_t.x[ dfc_tgt_i.vec_t.size-1 ] + dfc_tgt_i.dt_sample 
  
  dfc_recL = new List()
  sL = str.split( dfc_i.hoc_var, ";" )	// split to get list of recording section locations
  for i=0, sL.count-1 execute( str.sPrint( "%s dfc_recL.append( new SectionRef())", sL.o(i).s1 ).s1 )

  dfc_do_cmd( dfc_i.hoc_before )	// hoc_before here; so stim parms can be set in hoc_before code

  dfc_sim_recL = new List()
  for irec=0, dfc_recL.count-1 {
    dfc_sim_recL.append( new eTrace() )
    set_sim_stim( dfc_sim_recL.o(irec), stim )    
    //    dfc_sim_recL.o(irec).stim_amp = stim.amp
    //    dfc_sim_recL.o(irec).stim_dur = stim.dur
    //    dfc_sim_recL.o(irec).stim_del = stim.del
    dfc_sim_recL.o(irec).idebug = dfc_idebug
    dfc_sim_recL.o(irec).dt_sample = -1		// -1 => non-uniform for cvode
    dfc_sim_recL.o(irec).name = sL.o(irec).s1	// place recording section in name
    dfc_recL.o(irec).sec cvode.record( &v(0.5), dfc_sim_recL.o(irec).vec_v, dfc_sim_recL.o(irec).vec_t )
  }
  access dfc_recL.o(0).sec

  if( ! iss_unstable ){		// run only if previous case was stable (ie not unstable); see init()
    printf( "\n\t" )
    system( "date" )
    printf( "case %s\n", dfc_i.id )
    tgt_bldiff = dfc_i.tgt_bldiff
    pDE_asg()
    run() 
    dfc_simL_i = new List()
    for irec=0, dfc_recL.count-1 dfc_simL_i.append( dfc_sim_recL.o(irec).copy() )
    dfc_simL.append( dfc_simL_i )
  }  
  if( iss_unstable ){
    dfc_err = iss.dV / iss_unstable_th * iss_unstable_penalty
  }else{
    dfc_do_cmd( dfc_i.hoc_after )	// hoc_after
    dfc_err = 0 
    //    dfc_err = dfc_eD.listM( dfc_i.Mfunc, dfc_sim, dfc_tgtLi ) 
    dfc_eD.ilog = 1
    printf( "id %s ", dfc_i.id )
    //    sprint( str.s1, "dfc_err = dfc_eD.%s( dfc_sim, dfc_tgt_i )", dfc_i.Mfunc )
    //    sprint( str.s1, "dfc_err = dfc_eD.%s( dfc_simL_i.o(0), dfc_tgt_i )", dfc_i.Mfunc )
    //    execute( str.s1 )
    execute( str.sPrint( "dfc_err=%s", dfc_i.Mfunc).s1 )
  }
  execute( str.sPrint( "dfc_scaleF = %s", dfc_i.scaleF ).s1 )
  printf( " dfc_scaleF %g pDE_do_fit_case %g\n", dfc_scaleF, dfc_err*dfc_scaleF )

  return dfc_err * dfc_scaleF
}

//----------------------------------------------------------------------------------------------------
begintemplate recSpec
  objref sr, eT
  strdef name
  public name, sr, vr, eT, dist, tzc
  proc init(){
    sr = new SectionRef()
    name = secname()
    vr = $1
    dist = distance( vr )
    eT = new eTrace()
  }
  public set_eT
  obfunc set_eT(){
    eT = $o1.copy()
    eT.resample_dt(0.01)
    eT.vec_dv.deriv( eT.vec_v, eT.dt_sample, 2 )
    eT.vec_ddv = new Vector()
    eT.vec_ddv.deriv( eT.vec_dv, eT.dt_sample, 2 )
    tzc = eT.vec_t.x( eT.vec_v.indwhere(">=",0) )
    return eT
  }
  public sort_dist
  obfunc sort_dist(){ local i localobj iO, iOs, rL, rLs
    rL = $o1
    iO = new Vector()
    for i=0, rL.count-1 iO.append( rL.o(i).dist )
    iOs = iO.sortindex()
    rLs = new List()
    for i=0, rL.count-1 rLs.append( rL.o(iOs.x[i]) )
    return rLs
  }
endtemplate recSpec

//----------------------------------------------------------------------------------------------------
// Run again case icase and return eTrace results
obfunc dfc_run_againL(){ local i, icase localobj eT, eT1, dfc_i, dfc_tgt_i, rL, eTL
  icase = $1
  dfc_i = pDE_fc_list.o( icase )
  dfc_tgt_i = dfc_tgtL.o( icase )
  pDE_init_cell()
  dfc_do_cmd( dfc_i.hoc_before )
  tstop = dfc_tgt_i.vec_t.x[ dfc_tgt_i.vec_t.size-1 ] + dfc_tgt_i.dt_sample 
  tgt_bldiff = dfc_i.tgt_bldiff
  
  rL = new List()
  access   soma 
  distance()
  rL.append( new recSpec( x ))
  forsec "axon" for (x) if(x>0&&x<1) rL.append( new recSpec( x ))
  eTL = new List()
  for i=0, rL.count-1 {
    eTL.append( new eTrace() )
    set_sim_stim( eTL.o(i), stim )    
    rL.o(i).sr.sec cvode.record( &v( rL.o(i).vr ), eTL.o(i).vec_v, eTL.o(i).vec_t )
  }
  run()
  for i=0, rL.count-1 rL.o(i).set_eT( eTL.o(i) )
  return rL
}

// Return (and plot if pG present) rL for each parm value variation runs vp+ivp*k1 to vp+ivp*k2 in ivp steps
// ( icase, "var", vp, ivp, k1, k2 [, pG [,opt]] )
obfunc dfc_var_runsL(){ local i, imin, tmin, icase, vp, ivp, nv, k, k1, k2, opt localobj eT, eT1, eTL, str, pG, rL, rLL
  icase = $1
  str = new str_obj( $s2 )
  { vp=$3 ivp=$4 k1=$5 k2=$6 }
  rLL = new List()
  for k=k1, k2 {
    nv = vp + ivp * k
    sprint( str.s2, "%s=%g", str.s1, nv )
    execute( str.s2 )
    rL = dfc_run_againL(icase) 
    rL.o(0).eT.name = str.s2
    rLL.append( rL )
  }
  if( numarg()>6 ){ 
    eT = plot_rLL_dt( rLL )
    $o7 = eT.plotG
    { eT.plotG.view(0,0,10,10, 100+20+300*1.8, 100, 300*2.5, 200*3 ) eT.plotG.exec_menu( "View = plot" ) }
    { opt = 101 if( numarg()>8 ) opt = $9 }
    pG = new Graph(0)
    for k=0, rLL.count-1 pG = rLL.o(k).o(0).eT.iso_spike(dfc_seg_look_options(),1,-0.5,0).plot_ddv( pG, opt, k+1 )
    { pG.view(0,0,10,10, 100, 100, 300*1.8, 200*3 ) pG.exec_menu( "View = plot" ) }
    $o8 = pG
  }
  return rLL
}

obfunc plot_rLL_dt(){ local k, i, imin, tmin localobj eT, eT1, rLL, rL
  rLL = $o1
  eT = new eTrace()
  eT.plotG = new Graph(0)
  for k=0, rLL.count-1 {
    rL = rLL.o(k)
    tmin = 1e70
    for i=0, rL.count-1 {
      eT.plotG.mark( rL.o(i).dist, rL.o(i).tzc, "s", 5, axon_color( rL.o(i).name), 1 )
      if( rL.o(i).tzc<tmin ){ imin=i tmin=rL.o(i).tzc }
    }
    for i=0, rL.count-1 if( rL.o(i).tzc==tmin ) eT.plotG.mark( rL.o(i).dist, rL.o(i).tzc, "S", 6, axon_color( rL.o(i).name), 1 )
    
    // if(k==0){ eT.plotG=new Graph() eT.plotG.align( 1, 1 ) eT.plotG.label( 1-1/22, 1-1/22 ) }
    eT1 = rL_td_eT( rL )
    sprint( eT1.name, "%s t=%4.2f vel=%4.2f", rL.o(0).eT.name, tmin, axon_speed(rL) )
    eT.addplot_c( eT1, k%7+1 )
  }
  return eT
}

obfunc run_plot_all_axon_ddv(){ local i, icase, tspk, tL, tR localobj pG, rL, sf, eT
  icase = $1
  tL=-0.5 if( numarg()>1 )tL=$2
  tR=0    if( numarg()>2 )tR=$3
  sf = new StringFunctions()
  rL = dfc_run_againL( icase ) // rL.o(0) is soma
  pG = new Graph()
  rL.o(0).eT.copy().iso_spike(dfc_seg_look_options(),1,-0.5,0, &tspk )
  printf( "tspk %g\n", tspk )
  for i=0, rL.count-1 {
    if( sf.substr(rL.o(i).name, "node")>=0 || sf.substr(rL.o(i).name, "myelin")>=0 ) continue
    pG.color( axon_color(rL.o(i).name ))
    eT = rL.o(i).eT.copy().cut_at2( tspk+tR, tspk+tL )
    eT.vec_t.add( tL )
    // pG = rL.o(i).eT.copy().cut_at2(tspk+0.1,tspk-0.5).plot_ddv( pG, 001, axon_color(rL.o(i).name) )
    eT.vec_ddv.line( pG , eT.vec_t )
  }
  pG.exec_menu( "View = plot" )
  return pG
}

// calculate speed between nodes with min and max tzc
func axon_speed(){ local i, im, iM, vel localobj rL, sf
  rL = $o1
  sf = new StringFunctions()
  im=iM=-1
  for i=0, rL.count-1 if( sf.substr( rL.o(i).name, "node")>=0 ){
    if( im<0 ) im=iM=i // set to first "node" match
    if( rL.o(i).tzc < rL.o(im).tzc ) im=i
    if( rL.o(i).tzc > rL.o(iM).tzc ) iM=i
  }
  vel = ( rL.o(iM).dist - rL.o(im).dist ) / ( rL.o(iM).tzc - rL.o(im).tzc ) * 1e-3 // um/ms * 1e-3 = m/s 
  printf( "axon_speed: i,tzc min %g %g Max %g %g vel %g\n", im, rL.o(im).tzc, iM, rL.o(iM).tzc, vel )
  return vel
}

func axon_color(){ local i, col localobj str, sf
  str = new str_obj( $s1 )
  sf = new StringFunctions()
  col = 1
  if( sf.head( str.s1, "hill", str.s2 )> 0 ) col = 2
  if( sf.head( str.s1, "iseg", str.s2 )> 0 ) col = 3
  if( sf.head( str.s1, "prox", str.s2 )> 0 ) col = 4
  if( sf.head( str.s1, "myelin", str.s2 )> 0 ) col = 5
  if( sf.head( str.s1, "node", str.s2 )> 0 ) col = 6
  return col
}

//----------------------------------------------------------------------------------------------------
// Run again case icase and return eTrace results
obfunc dfc_run_again(){ local icase localobj eT, eT1, dfc_i, dfc_tgt_i
  icase = $1
  dfc_i = pDE_fc_list.o( icase )
  dfc_tgt_i = dfc_tgtL.o( icase )
  pDE_init_cell()
  dfc_do_cmd( dfc_i.hoc_before )
  tstop = dfc_tgt_i.vec_t.x[ dfc_tgt_i.vec_t.size-1 ] + dfc_tgt_i.dt_sample 
  tgt_bldiff = dfc_i.tgt_bldiff

  eT = new eTrace()
  set_sim_stim( eT, stim )    
  soma cvode.record( &v(0.5), eT.vec_v, eT.vec_t )
  run()
  eT1 = eT.copy()
  eT1.resample_dt(0.01)
  eT1.vec_dv.deriv( eT1.vec_v, eT1.dt_sample, 2 )
  eT1.vec_ddv = new Vector()
  eT1.vec_ddv.deriv( eT1.vec_dv, eT1.dt_sample, 2 )
  return eT1
}

//----------------------------------------------------------------------------------------------------
// Return (and plot if pG present) list of parm value variation runs vp+ivp*k1 to vp+ivp*k2 in ivp steps
obfunc dfc_var_runs(){ local icase, vp, ivp, nv, k, k1, k2, opt localobj eT, eTL, str, pG
  icase = $1
  str = new str_obj( $s2 )
  { vp=$3 ivp=$4 k1=$5 k2=$6 }
  eTL = new List()
  for k=k1, k2 {
    nv = vp + ivp * k
    sprint( str.s2, "%s = %g", str.s1, nv )
    execute( str.s2 )
    eT = dfc_run_again(icase) 
    eT.name = str.s2
    eTL.append( eT )
  }
  if( numarg()>6 ){
    { opt = 101 if( numarg()>7 ) opt = $8 }
    for k=0, eTL.count-1 pG=(eTL.o(k).iso_spike(dfc_seg_look_options(),1,1).plot_ddv( pG, opt, k+1 ))
    // Note parens. below does not work
    //for k=0, eTL.count-1 pG=eT.plot_ddv( pG, eTL.o(k).iso_spike(dfc_eD_options(),1,1), opt, k+1 )
    $o7 = pG
  }
  return eTL
}

//----------------------------------------------------------------------------------------------------
proc dfc_plot_1(){ local i, n 
  $o1.plot_color = $3
  $o1.plot_brush = $4
  $o1.addplot( $o2 ) 
}

proc dfc_plot_place(){ local n
  n = $2
  $o1.plotG.unmap()
  $o1.plotG.view(0,0,10,10, (n%5)*(300+20), 100+int(n/5)*(200+65), 300, 200 )
  $o1.recenter()
}

func is_obj_name(){ local i localobj sf, str
  str = new str_obj($s2)  sf = new StringFunctions()
  sprint( str.s2, "%s", $o1 )
  if( sf.tail( str.s2, str.s1, str.s3 ) == sf.len(str.s1) ) return 1
  return 0
}

objref igL
strdef pDE_log_name
obfunc plot_gen(){
  igL = new pDE_log()
  igL.read_n_plot( pDE_log_name, pDE_gen_N )
  return igL
}

objref pG_axon, pG_sec
obfunc plot_axon(){ local i, in localobj str
  pG_axon = new Graph()
  pG_sec = new List()
  str = new str_obj()
  pG_sec.append( new str_obj( "axon_hill" ))
  in = 19
  if( vdef( "aX_iseg_n" )) in = aX_iseg_n
  for i=0,in-1 pG_sec.append( str.copy().sPrint( "axon_iseg[%d]", i ) )
  pG_sec.append( new str_obj( "axon_prox" ))
  if( aX_node_n > 0 ){
    pG_sec.append( new str_obj( "axon_node[0]" ))
    pG_sec.append( new str_obj( "axon_myelin[0]" ))
  }
  pG_sec.append( new str_obj( "soma" ))		// put last so that soma is accessed at the end below
  for i=0, pG_sec.count-1 {
    execute( pG_sec.o(0).sPrint( "access %s", pG_sec.o(i).s1 ).s1 )
    pG_axon.mark( distance(0.5), gbar_Naf2_i1, "+", 12, 2, 1 )    
    pG_axon.mark( distance(0.5), gbar_KDR_i1, "o", 12, 3, 1 )    
  }
  pG_axon.exec_menu( "View = plot" )
  return pG_axon
}

objref dfc_ddVpG
obfunc dfc_pG_ddV(){ local i, iopt localobj pG
  pG = $o1
  iopt = $2
  if( iopt==0 ) for i=0,dfc_tgtL.count-1 { dfc_pG_one_ddV(pG,i,001,0,1)   dfc_pG_one_ddV(pG,i,001,1,2) }
  if( iopt==1 ) for i=0,dfc_tgtL.count-1 { dfc_pG_one_ddV(pG,i,001,0,i+1,1) dfc_pG_one_ddV(pG,i,001,1,i+1,2) }
  if( iopt==2 ) for i=0,dfc_tgtL.count-1 { dfc_pG_one_ddV(pG,i,010,0,1)   dfc_pG_one_ddV(pG,i,010,1,2) }
  if( iopt==3 ) for i=0,dfc_tgtL.count-1 { dfc_pG_one_ddV(pG,i,010,0,i+1,1) dfc_pG_one_ddV(pG,i,010,1,i+1,2) }
  return pG
}

obfunc dfc_pG_one_ddV(){ local icase, iopt, isel, icol, ibrush localobj eT, pG, eTc
  if(numarg()>0 ) pG=$o1 
  if( object_id( pG )==0 ) { pG = new Graph() }
  icase=$2 iopt=$3 isel=$4 icol=$5 
  dfc_i = pDE_fc_list.o( icase )
  ibrush=1 if( numarg()>5 ) ibrush=$6
  pG.brush( ibrush )
  if( isel==0 ) eTc = dfc_tgtL.o(icase)
  if( isel==1 ) eTc = dfc_simL.o(icase).o(0)
  if( eTc.stim_amp<0.2 || eTc.stim_amp==0.75 ) return pG
  eT = eTc.iso_spike( dfc_seg_look_options(), 1, -0.65, 0.45 )
  if( object_id(eT)>0) eT.plot_ddv( pG, iopt, icol )
  return pG
}

// per fit-case: dfc_simL has one list entry (with eTraces); dfc_tgtL has one eTrace 
proc dfc_plot_all(){ local i, j localobj eTi
  for i=0, dfc_simL.count-1 {
    eTi = dfc_tgtL.o(i)
    for j=0, dfc_simL.o(i).count-1 dfc_plot_1( eTi, dfc_simL.o(i).o(j), 2+j, 1 )
    dfc_plot_1( eTi, eTi, 1, 1 )
    //    for j=0, dfc_tgtL.o(i).count-1 dfc_plot_1( eTi, dfc_tgtL.o(i).o(j), 1, 1 )
    dfc_plot_place( eTi, i )
    eTi.plotG.menu_action("plot_gen","plot_gen()" )
    eTi.plotG.menu_action("plot_axon","plot_axon()" )
    eTi.plotG.menu_action("plot_ddVs_all","dfc_ddVpG=new Graph() dfc_pG_ddV(dfc_ddVpG,0)" )
    eTi.plotG.menu_action("plot_ddVs_color","dfc_ddVpG=new Graph() dfc_pG_ddV(dfc_ddVpG,1)" )
    eTi.plotG.menu_action("plot_dVs","dfc_ddVpG=new Graph() dfc_pG_ddV(dfc_ddVpG,2)" )
    eTi.plotG.menu_action("plot_dVs_color","dfc_ddVpG=new Graph() dfc_pG_ddV(dfc_ddVpG,3)" )
  }
}

proc dfc_plot_all_old(){ local i 
  for i=0, dfc_simL.count-1 dfc_plot_one( dfc_simL.o(i), dfc_tgtL.o(i), i )
}

//================================================================================
obfunc rL_td_eT(){ local i localobj rL, eT, sIc, sI
  rL = $o1
  eT = new eTrace()
  sIc = new Vector()
  for i=0, rL.count-1 sIc.append( rL.o(i).dist )
  sI = sIc.sortindex()
  for i=0, rL.count-1 {
    eT.vec_t.append( rL.o(sI.x[i]).dist)
    eT.vec_v.append( rL.o(sI.x[i]).tzc )
  }
  return eT
}

//--------------------------------------------------------------------------------
// Usage above
// objref rLL, pGd, pG

// { pDE_asg() rLL = dfc_var_runsL( 0, "aXh_Gbar_Naf", aXh_Gbar_Naf, aXh_Gbar_Naf*0.1, -2, 2, pGd, pG ) }
// abort()


// end of pDE interface related code
//================================================================================



